"""
Custom SQL Correctness Metric using DeepEval's G-Eval framework.
Evaluates SQL query correctness including syntax, semantics, and business logic.
"""

from typing import List, Dict, Any, Optional
import sqlparse
from sqlglot import parse_one, ParseError
from deepeval.metrics import GEval
from deepeval.test_case import LLMTestCaseParams
from config import EvaluationConfig


class SqlCorrectnessMetric(GEval):
    """
    Custom metric to evaluate SQL query correctness.

    Evaluates:
    - SQL syntax validity
    - Semantic correctness (uses correct tables/columns)
    - Logic correctness (matches business requirements)
    - Query efficiency (proper use of indexes, JOINs, etc.)
    """

    def __init__(
        self,
        threshold: float = 0.7,
        name: str = "SQL Correctness",
        include_reason: bool = True,
        strict_mode: bool = False,
    ):
        """
        Initialize SQL Correctness metric.

        Args:
            threshold: Minimum score (0-1) for test to pass
            name: Metric name for reporting
            include_reason: Whether to include reasoning in output
            strict_mode: If True, requires perfect score to pass
        """
        # Get model config from central configuration
        model_config = EvaluationConfig.get_model_config()

        evaluation_params = [
            LLMTestCaseParams.INPUT,
            LLMTestCaseParams.ACTUAL_OUTPUT,
            LLMTestCaseParams.EXPECTED_OUTPUT,
        ]

        super().__init__(
            name=name,
            criteria=self._get_evaluation_criteria(),
            evaluation_params=evaluation_params,
            evaluation_steps=self._get_evaluation_steps(),
            threshold=threshold,
            model=model_config.get("model"),
            include_reason=include_reason,
            strict_mode=strict_mode,
        )

    def _get_evaluation_criteria(self) -> str:
        """Define the evaluation criteria for SQL correctness."""
        return """
You are evaluating the correctness of a SQL query generated by an AI agent.
The query should be syntactically valid, semantically correct, and solve the business question effectively.

Evaluate the actual SQL query against the expected SQL query and the original question.

Consider these aspects:
1. **Syntax Validity**: Is the SQL syntactically correct and executable?
2. **Semantic Correctness**: Does it use the correct tables, columns, and JOINs?
3. **Logic Correctness**: Does it answer the question accurately?
4. **Query Efficiency**: Does it use appropriate indexes, avoid unnecessary operations?
5. **Edge Cases**: Does it handle NULLs, duplicates, and empty results properly?

Score from 0 to 1, where:
- 1.0: Perfect query that matches expected logic
- 0.7-0.9: Correct query with minor style or efficiency differences
- 0.4-0.6: Query works but has significant logic or efficiency issues
- 0.0-0.3: Query is incorrect or will produce wrong results
"""

    def _get_evaluation_steps(self) -> List[str]:
        """Define step-by-step evaluation process."""
        return [
            "Parse and validate the SQL syntax of the actual query",
            "Compare the tables and columns used against the expected query",
            "Verify that JOINs, WHERE clauses, and GROUP BY logic match requirements",
            "Check that aggregations (SUM, COUNT, AVG) are used correctly",
            "Evaluate if the query will produce the correct result for the given question",
            "Assess query efficiency (proper filtering, unnecessary subqueries, etc.)",
            "Provide a final score from 0 to 1 based on overall correctness",
        ]

    @staticmethod
    def validate_sql_syntax(sql: str) -> Dict[str, Any]:
        """
        Validate SQL syntax using sqlparse and sqlglot.

        Returns:
            Dict with 'is_valid', 'error', and 'parsed' keys
        """
        result = {
            "is_valid": False,
            "error": None,
            "parsed": None,
        }

        if not sql or not sql.strip():
            result["error"] = "SQL query is empty"
            return result

        try:
            # Parse with sqlparse (more lenient, good for formatting check)
            parsed_sqlparse = sqlparse.parse(sql)
            if not parsed_sqlparse:
                result["error"] = "Failed to parse SQL"
                return result

            # Parse with sqlglot (stricter, better error messages)
            parsed_sqlglot = parse_one(sql, read="postgres")
            result["parsed"] = parsed_sqlglot
            result["is_valid"] = True

        except ParseError as e:
            result["error"] = f"SQL Parse Error: {str(e)}"
        except Exception as e:
            result["error"] = f"Unexpected error: {str(e)}"

        return result

    @staticmethod
    def extract_sql_components(sql: str) -> Dict[str, List[str]]:
        """
        Extract key components from SQL query for validation.

        Returns:
            Dict with 'tables', 'columns', 'joins', 'aggregates' keys
        """
        components = {
            "tables": [],
            "columns": [],
            "joins": [],
            "aggregates": [],
            "where_clauses": [],
            "group_by": [],
            "order_by": [],
        }

        try:
            parsed = parse_one(sql, read="postgres")

            # Extract tables
            for table in parsed.find_all("Table"):
                components["tables"].append(table.name)

            # Extract columns
            for column in parsed.find_all("Column"):
                components["columns"].append(str(column))

            # Extract aggregates
            for agg in parsed.find_all("AggFunc"):
                components["aggregates"].append(str(agg.this))

            # Extract joins
            for join in parsed.find_all("Join"):
                components["joins"].append(str(join))

        except Exception:
            # If parsing fails, return empty components
            pass

        return components

    def validate_against_criteria(
        self,
        actual_sql: str,
        expected_sql: str,
        criteria: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Validate actual SQL against expected criteria.

        Args:
            actual_sql: The generated SQL query
            expected_sql: The expected/golden SQL query
            criteria: Dict of validation criteria from test case

        Returns:
            Dict with validation results
        """
        validation = {
            "passed": True,
            "failures": [],
            "warnings": [],
        }

        # Extract components
        actual_components = self.extract_sql_components(actual_sql)
        expected_components = self.extract_sql_components(expected_sql)

        # Check required tables
        if "must_use_tables" in criteria:
            missing_tables = set(criteria["must_use_tables"]) - set(actual_components["tables"])
            if missing_tables:
                validation["passed"] = False
                validation["failures"].append(f"Missing required tables: {missing_tables}")

        # Check required columns
        if "must_use_columns" in criteria:
            for required_col in criteria["must_use_columns"]:
                if not any(required_col in col for col in actual_components["columns"]):
                    validation["warnings"].append(f"May be missing required column: {required_col}")

        # Check for DISTINCT if required
        if criteria.get("must_have_distinct", False):
            if "DISTINCT" not in actual_sql.upper():
                validation["passed"] = False
                validation["failures"].append("Query must use DISTINCT")

        # Check for JOINs if required
        if criteria.get("must_join", False):
            if not actual_components["joins"] and "JOIN" not in actual_sql.upper():
                validation["passed"] = False
                validation["failures"].append("Query must use JOIN")

        # Check for GROUP BY if required
        if "must_group_by" in criteria:
            if "GROUP BY" not in actual_sql.upper():
                validation["passed"] = False
                validation["failures"].append("Query must use GROUP BY")

        # Check for required aggregates
        if "must_aggregate" in criteria:
            for agg in criteria["must_aggregate"]:
                if agg.upper() not in actual_sql.upper():
                    validation["failures"].append(f"Query must use {agg} aggregate")

        # Check for HAVING if required
        if criteria.get("must_have_having", False):
            if "HAVING" not in actual_sql.upper():
                validation["warnings"].append("Query might need HAVING clause")

        # Check for window functions if required
        if criteria.get("must_use_window_function", False):
            if "OVER" not in actual_sql.upper():
                validation["passed"] = False
                validation["failures"].append("Query must use window function (OVER)")

        # Check for CTE if required
        if criteria.get("must_use_cte", False):
            if "WITH" not in actual_sql.upper():
                validation["passed"] = False
                validation["failures"].append("Query must use CTE (WITH)")

        return validation


def create_sql_correctness_metric(
    threshold: Optional[float] = None,
    strict_mode: bool = False,
) -> SqlCorrectnessMetric:
    """
    Factory function to create SQL correctness metric with config.

    Args:
        threshold: Override default threshold
        strict_mode: Require perfect score

    Returns:
        Configured SqlCorrectnessMetric instance
    """
    threshold = threshold or EvaluationConfig.DEEPEVAL_THRESHOLD

    return SqlCorrectnessMetric(
        threshold=threshold,
        include_reason=EvaluationConfig.DEEPEVAL_VERBOSE,
        strict_mode=strict_mode,
    )
